Day 12 Programs
A grid of light bulbs is given, represented as a matrix of size rows x cols, 
where each cell contains either 0 (off) or 1 (on).

Your task is to turn all the light bulbs off (0) by following the toggle rule:
    - In each step, you can choose either an entire row or an entire column 
    and toggle all its elements (change 0 to 1 and 1 to 0).
    
At the end, if all light bulbs are turned off, print true, otherwise print false.


Input Format
-------------
Line-1: Read two integers rows and cols(space separated).
Line-2: Read the matrix of dimension rows X cols.

Output Format
--------------
Print a boolean result.



Sample input-1:
---------------
5 5
0 0 1 0 0
0 0 1 0 0
1 1 0 1 1
0 0 1 0 0
0 0 1 0 0

Sample output-1:
----------------
true

Explanation:
------------
0 0 1 0 0          0 0 1 0 0           0 0 0 0 0
0 0 1 0 0   row-3  0 0 1 0 0   cols-3  0 0 0 0 0
1 1 0 1 1   --->   0 0 1 0 0   --->    0 0 0 0 0
0 0 1 0 0          0 0 1 0 0           0 0 0 0 0
0 0 1 0 0          0 0 1 0 0           0 0 0 0 0 


Sample input-2
--------------
2 2
1 1
0 1

Sample output-2
---------------
false
import java.util.*;
class Sol{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int[][] g=new int[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                g[i][j]=sc.nextInt();
            }
        }
        int count=0;
        for(int i=1;i<g.length;i++){
            if(Arrays.equals(g[0],g[i]) || Arrays.equals(g[0],check(g[i]))) count++;
        }
        if(count==n-1) System.out.println("true");
        else System.out.println("false");
    }
    static int[] check(int[] arr){
        int[] or=new int[arr.length];
        for(int i=0;i<arr.length;i++){
            if(arr[i]==0){
                or[i]=1;
            }
            else if(arr[i]==1){
                or[i]=0;
            }
        }
        return or;
    }
}



A software development company is designing a smart home automation 
system that uses sensor networks to monitor and control different devices 
in a house. The sensors are organized in a hierarchical structure, where each 
sensor node has a unique ID and can have up to two child nodes (left and right).

The company wants to analyze the left-most sensors in the system to determine
which ones are critical for detecting environmental changes. The hierarchy of 
the sensors is provided as a level-order input, where missing sensors are 
represented as -1.

Your task is to build the sensor network as a binary tree and then determine 
the left-most sensor IDs at each level.

Refernce Node:
--------------
class TreeNode {
    Integer val;
    TreeNode left, right;
    
    TreeNode(Integer val) {
        this.val = val;
        this.left = this.right = null;
    }
}


Input Format:
-------------
Space separated integers, elements of the tree.

Output Format:
--------------
A list of integers representing the left-most sensor IDs at each level


Sample Input-1:
---------------
1 2 3 4 -1 -1 5

Sample Output-1:
----------------
[1, 2, 4]



Sample Input-2:
---------------
3 2 4 1 5

Sample Output-2:
----------------
[3, 2, 1]


import java.util.*;
class Sol{
    static class Node{
        int data;
        Node left;
        Node right;
        Node(int data){
            this.data=data;
        }
    }
    static Node build(int[] arr){
        if(arr.length==0 || arr[0]==-1) return null;
        Queue<Node> q=new LinkedList<>();
        Node root=new Node(arr[0]);
        q.add(root);
        int i=1;
        while(!q.isEmpty()){
            Node curr=q.poll();
            if(i<arr.length && arr[i]!=-1){
                Node left=new Node(arr[i]);
                curr.left=left;
                q.add(left);
            }
            i++;
             if(i<arr.length && arr[i]!=-1){
                Node right=new Node(arr[i]);
                curr.right=right;
                q.add(right);
            }
            i++;
        }
        return root;
    }
    static ArrayList<Integer> leftView(Node root){
        ArrayList<Integer> arr=new ArrayList<>();
        if(root==null) return arr;
        Queue<Node> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int n=q.size();
            for(int i=0;i<n;i++){
                Node curr=q.poll();
                if(i==0) arr.add(curr.data);
                if(curr.left!=null) q.add(curr.left);
                if(curr.right!=null) q.add(curr.right);
            }
        }
        return arr;
        
    }
    static void dfs(Node root,ArrayList<Integer> arr){
         if(root==null) return;
         arr.add(root.data);
         if(root.left!=null) dfs(root.left,arr);
         else if (root.right!=null) dfs(root.right,arr);
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String[] p=sc.nextLine().split(" ");
        int[] arr=new int[p.length];
        for(int i=0;i<p.length;i++){
            arr[i]=Integer.parseInt(p[i]);
        }
        Node root=build(arr);
        System.out.println(leftView(root));
        ArrayList<Integer> arr1=new ArrayList<>();
        dfs(root,arr1);
        System.out.println(arr1);
        
    }
}

The Indian Army has established multiple military camps at strategic locations 
along the Line of Actual Control (LAC) in Galwan. These camps are connected in 
a hierarchical structure, with a main base camp acting as the root of the network.

To fortify national security, the Government of India has planned to deploy 
a protective S.H.I.E.L.D. that encloses all military camps forming the outer 
boundary of the network.

Structure of Military Camps:
    - Each military camp is uniquely identified by an integer ID.
    - A camp can have at most two direct connections:
        - Left connection → Represents a subordinate camp on the left.
        - Right connection → Represents a subordinate camp on the right.
    - If a military camp does not exist at a specific position, it is 
      represented by -1
	
Mission: Deploying the S.H.I.E.L.D.
Your task is to determine the list of military camp IDs forming the outer 
boundary of the military network. This boundary must be traversed in 
anti-clockwise order, starting from the main base camp (root).

The boundary consists of:
1. The main base camp (root).
2. The left boundary:
    - Starts from the root’s left child and follows the leftmost path downwards.
    - If a camp has a left connection, follow it.
    - If no left connection exists but a right connection does, follow the right connection.
    - The leftmost leaf camp is NOT included in this boundary.
3. The leaf camps (i.e., camps with no further connections), ordered from left to right.
4. The right boundary (in reverse order):
    - Starts from the root’s right child and follows the rightmost path downwards.
    - If a camp has a right connection, follow it.
    - If no right connection exists but a left connection does, follow the left connection.
    - The rightmost leaf camp is NOT included in this boundary.

Refernce Node:
--------------
class TreeNode {
    Integer val;
    TreeNode left, right;
    
    TreeNode(Integer val) {
        this.val = val;
        this.left = this.right = null;
    }
}


Input Format:
-------------
space separated integers, military-camp IDs.

Output Format:
--------------
Print all the military-camp IDs, which are at the edge of S.H.I.E.L.D.


Sample Input-1:
---------------
5 2 4 7 9 8 1

Sample Output-1:
----------------
[5, 2, 7, 9, 8, 1, 4]


Sample Input-2:
---------------
11 2 13 4 25 6 -1 -1 -1 7 18 9 10

Sample Output-2:
----------------
[11, 2, 4, 7, 18, 9, 10, 6, 13]


Sample Input-3:
---------------
1 2 3 -1 -1 -1 5 -1 6 7

Sample Output-3:
----------------
[1, 2, 7, 6, 5, 3]


import java.util.*;
class Sol{
    static class Node{
        int data;
        Node left;
        Node right;
        Node(int data){
            this.data=data;
        }
    }
    static Node build(int[] arr){
        if(arr.length==0 || arr[0]==-1) return null;
        Node root=new Node(arr[0]);
        Queue<Node> q=new LinkedList<>();
        q.add(root);
        int i=1;
        while(!q.isEmpty()){
            Node curr=q.poll();
            if(i<arr.length && arr[i]!=-1){
                curr.left=new Node(arr[i]);
                q.add(curr.left);
            }
            i++;
            if(i<arr.length && arr[i]!=-1){
                curr.right=new Node(arr[i]);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }
    static List<Integer> boundary(Node root) {
        List<Integer> nodes = new ArrayList<>();
        if(root==null|| root.data==-1) return nodes;
        nodes.add(root.data);
        left(root.left,nodes);
        leaves(root,nodes);
        right(root.right,nodes);
        return nodes;
    }
    static void left(Node root,List<Integer> nodes) {
        if (root==null || (root.left==null && root.right==null)) return;
        nodes.add(root.data);
        if (root.left==null)
            left(root.right,nodes);
        else
            left(root.left,nodes);
    }
    static void leaves(Node root, List<Integer> nodes) {
        if (root==null) return;
        if ((root.left==null) && (root.right==null)) {
            nodes.add(root.data);
            return;
        }
        leaves(root.left,nodes);
        leaves(root.right,nodes);
    }
    static void right(Node root, List<Integer> nodes) {
        if (root==null || ((root.left==null) &&  (root.right==null))) return;
        if (root.right!=null)
            right(root.right,nodes);
        else
            right(root.left,nodes);
        nodes.add(root.data);
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String[] p=sc.nextLine().split(" ");
        int[] arr=new int[p.length];
        for(int i=0;i<p.length;i++){
            arr[i]=Integer.parseInt(p[i]);
        }
        Node root=build(arr);
        System.out.println(boundary(root));
    }
}