Day 12- Multi threading
D12 Program-5-MultiThreading MaxPool
You are given a 2-dimensional integer matrix representing a feature map obtained 
from a convolutional layer of a neural network. Your task is to compute the Max 
Pooling â€“ Forward Pass on this matrix using Java multithreading.

Max Pooling reduces the spatial dimensions of the input matrix by sliding a fixed-size
window over it and selecting the maximum value from each window.

The computation must be performed in parallel, where multiple threads cooperate to 
compute different parts of the output matrix.

Pooling Rules
-------------
	Pooling window size is K Ã— K
	Stride is S
	No padding is applied
	Windows move from left to right and top to bottom

The output matrix dimensions are:
	Output Rows  = (H âˆ’ K) / S + 1
	Output Cols  = (W âˆ’ K) / S + 1
where H Ã— W is the size of the input matrix.

Multithreading Requirement
--------------------------
	The forward pooling computation must be parallelized
	Each thread should compute one or more output rows
	The final output must be deterministic and ordered

Input Format
------------
H W
H lines each containing W space-separated integers
K
S

Input Description
-----------------
H	  Number of rows in the input matrix
W	  Number of columns in the input matrix
K	  Pooling window size
S	  Stride

Output Format
-------------
Output matrix with each row printed on a new line
Each row contains space-separated integers

Sample Input
------------
4 4
1 3 2 4
5 6 1 2
0 2 4 1
3 1 0 2
2
2

Sample Output
-------------
6 4
3 4

Explanation 
--------------
A 2 Ã— 2 window slides over the matrix with stride 2
From each window, the maximum value is selected
These maximum values form the output matrix

Constraints
--------------
1 â‰¤ H, W â‰¤ 1000
1 â‰¤ K â‰¤ min(H, W)
1 â‰¤ S â‰¤ K
Input values are valid integers
(H âˆ’ K) and (W âˆ’ K) are divisible by S



import java.util.concurrent.*;
import java.util.*;

public class MaxPoolingForwardDynamicMT {

    static class PoolTask implements Callable<int[]> {
        int rowIndex;
        int[][] input;
        int poolSize,stride,outCols;
        PoolTask(int rowIndex,int[][] input,int poolSize,int stride,int outCols){
            this.rowIndex=rowIndex;
            this.input=input;
            this.poolSize=poolSize;
            this.stride=stride;
            this.outCols=outCols;
        }

        public int[] call() {
            int[] resultRow=new int[outCols];
            for (int j=0; j<outCols;j++) {
                int startRow=rowIndex*stride;
                int startCol=j*stride;
                int maxVal=Integer.MIN_VALUE;
                for (int r=0;r<poolSize;r++){
                    for(int c=0;c<poolSize;c++) {
                        maxVal=Math.max(maxVal,input[startRow+r][startCol+c]);
                    }
                }
                resultRow[j]=maxVal;
            }
            return resultRow;
        }
    }

    static int[][] maxPoolForward(int[][] input,int poolSize,int stride) throws Exception {
        int H=input.length;
        int W=input[0].length;
        int outRows=(H-poolSize)/stride+1;
        int outCols=(W-poolSize)/stride+1;
        int[][] output=new int[outRows][outCols];
        ExecutorService executor=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        List<Future<int[]>> futures=new ArrayList<>();
        for (int i=0;i<outRows;i++) {
            futures.add(executor.submit(new PoolTask(i,input,poolSize,stride,outCols)));
        }
        for (int i=0;i<outRows;i++){
            output[i]=futures.get(i).get();
        }
        executor.shutdown();
        return output;
    }

    public static void main(String[] args) throws Exception {
        Scanner sc=new Scanner(System.in);
        int H=sc.nextInt();
        int W=sc.nextInt();
        int[][] input=new int[H][W];
        for (int i=0;i < H; i++) {
            for (int j = 0; j < W; j++) {
                input[i][j] = sc.nextInt();
            }
        }

        int poolSize = sc.nextInt();
        int stride = sc.nextInt();

        int[][] output = maxPoolForward(input, poolSize, stride);

        for (int[] row : output) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }

        sc.close();
    }
}


D12 Program-6-MultiThreading-MatMul
You are given two matrices A and B.
Your task is to compute the matrix multiplication result C = A Ã— B.

The implementation must strictly follow this rule:
    - Each thread must be responsible for computing exactly one cell 
      of the result matrix.

This means that:
    One thread computes one value C[i][j]
    No thread may compute more than one cll
    No cell may be computed by more than one thread

ðŸ§  Matrix Multiplication Definition
-----------------------------------
Matrix A is of size R Ã— K
Matrix B is of size K Ã— C
Then the result matrix C is of size R Ã— C, where:
    C[i][j] = A[i][0]Ã—B[0][j] + A[i][1]Ã—B[1][j] + ... + A[i][Kâˆ’1]Ã—B[Kâˆ’1][j]

Multithreading Requirement
--------------------------
    - The total number of threads created must be equal to the number of cells in 
    the result matrix
    - Threads must run concurrently
    - Each thread must write its computed value directly to the shared result matrix
    - The final output must be correct and deterministic

Input Format
------------
R K
Matrix A (R rows and K columns)
K C
Matrix B (K rows and C columns)

Output Format
-------------
Result matrix C (R rows and C columns)
Each row printed on a new line with space-separated integers


Sample Input
------------
2 3
1 2 3
4 5 6
3 2
7 8
9 10
11 12

Sample Output
-------------
58 64
139 154
