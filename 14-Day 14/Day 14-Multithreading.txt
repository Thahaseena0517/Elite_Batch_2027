Day 14-Multithreading

D14 Program-1-MultiThreading PC

You are developing a multi-threaded backend system for an e-commerce platform.

The platform receives customer orders from multiple sources (mobile app, website, partner APIs).
These orders must be queued, processed, and dispatched concurrently.

To ensure scalability:
	- Order creation and order processing run in parallel
	- Orders are exchanged through a shared buffer with limited capacity

Order Information: Each order contains the following details:

--------------------------------------------------
Field						Description
--------------------------------------------------
orderId					Unique order identifier
customerName	Name of the customer
productName		Product ordered
quantity					Number of items
pricePerUnit			Cost per item
totalAmount			quantity × price
--------------------------------------------------

Input Format:
-----------------
BUFFER_CAPACITY
NUMBER_OF_ORDERS, N
Next N lines:
orderId customerName productName quantity pricePerUnit


Sample Input:
-----------------
3
4
1001 Alice Laptop 1 75000
1002 Bob Phone 2 20000
1003 Charlie Tablet 1 30000
1004 Diana Headphones 2 5000

Sample Output:
-------------------
PRODUCED Order[ID=1001, Customer=Alice, Product=Laptop, Qty=1, Total=75000.0]
PRODUCED Order[ID=1002, Customer=Bob, Product=Phone, Qty=2, Total=40000.0]
PRODUCED Order[ID=1003, Customer=Charlie, Product=Tablet, Qty=1, Total=30000.0]
PRODUCED Order[ID=1004, Customer=Diana, Product=Headphones, Qty=2, Total=10000.0]
CONSUMED Order[ID=1001, Total=75000.0]
CONSUMED Order[ID=1002, Total=40000.0]
CONSUMED Order[ID=1003, Total=30000.0]
CONSUMED Order[ID=1004, Total=10000.0]

import java.util.*;
import java.util.concurrent.*;

class Order {
    int orderId, quantity;
    String customerName, productName;
    double pricePerUnit, totalAmount;
    
    Order(int orderId, String customerName, 
    String productName, int quantity, double pricePerUnit) {
        this.orderId = orderId;
        this.quantity = quantity;
        this.customerName = customerName;
        this.productName = productName;
        this.pricePerUnit = pricePerUnit;
        this.totalAmount = pricePerUnit * quantity;
    }
}

class OrderBuffer {
    int cap;
    Queue<Order> q = new LinkedList<>();
    
    OrderBuffer(int bufferCapacity) {
        cap = bufferCapacity;
    }
    
    public synchronized void put(Order o) throws Exception {
        while(q.size() == cap) {
            wait();
        }
        q.add(o);

        notify();

    }
    
    public synchronized Order take() throws Exception {
        while(q.isEmpty()) {
            wait();
        }
        notify();

        return q.poll();
    }
}

    class OrderProducer implements Callable<List<String>> {
        private OrderBuffer buffer;
        private List<Order> orders;
        
        OrderProducer(OrderBuffer buffer, List<Order> orders) {
            this.buffer = buffer;
            this.orders = orders;
        }
        
        @Override 
        public List<String> call() throws Exception {
            List<String> prod = new ArrayList<>();
            
            for(Order o: orders) {
                buffer.put(o);
                prod.add("PRODUCED Order[ID="+o.orderId+
                ", Customer="+o.customerName+", Product="+o.productName+
                ", Qty="+o.quantity+", Total="+o.totalAmount+"]");
            }
            return prod;
        }
        
    }
    
    class OrderConsumer implements Callable<List<String>> {
        private OrderBuffer buffer;
        private int cnt;
        // private List<Order> orders = new ArrayList<>();
        
        OrderConsumer(OrderBuffer buffer, int n) {
            this.buffer = buffer;
            this.cnt = n;
        }
        
        @Override 
        public List<String> call() throws Exception {
            List<String> cons = new ArrayList<>();
            for(int i = 0; i < cnt; i++) {
                Order o = buffer.take();
                cons.add("CONSUMED Order[ID="+o.orderId+", Total="+o.totalAmount+"]");
            }
            return cons;
        }
    }
    

public class ProducerConsumerCallableDemo {
    
    
    /* ==========================
       IMPLEMENT YOUR CODE HERE
       ========================== */
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);

        int bufferCapacity = sc.nextInt();
        int n = sc.nextInt();

        List<Order> orders = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            orders.add(new Order(
                    sc.nextInt(),
                    sc.next(),
                    sc.next(),
                    sc.nextInt(),
                    sc.nextDouble()
            ));
        }

        OrderBuffer buffer = new OrderBuffer(bufferCapacity);
        ExecutorService executor = Executors.newFixedThreadPool(2);

        long start = System.currentTimeMillis();

        Future<List<String>> producerFuture =
                executor.submit(new OrderProducer(buffer, orders));

        Future<List<String>> consumerFuture =
                executor.submit(new OrderConsumer(buffer, n));

        /* ---- PHASE 1: PRINT PRODUCERS ---- */
        for (String log : producerFuture.get()) {
            System.out.println(log);
        }

        /* ---- PHASE 2: PRINT CONSUMERS ---- */
        for (String log : consumerFuture.get()) {
            System.out.println(log);
        }

        executor.shutdown();
        sc.close();
    }
}


DAY-14 PROGRAM 2
You are given N customer orders that must be processed sequentially.
Design a Java multithreading application using the Callable interface only, 
with the following strict constraints:
    - There is exactly ONE Producer task
    - There is exactly ONE Consumer task
    - The number of orders (N) and the list of orders are global shared objects
    - The Producer and Consumer must not receive the orders directly
    - The Producer and Consumer must communicate only through a shared handoff object
    - There is NO buffer, queue, or collection used for intermediate storage

Each order must be processed in the following strict order:
Producer processes one order → Consumer processes the same order → then move to the next order

The Producer must wait until the Consumer finishes processing the current order.
The Consumer must wait until the Producer produces the next order.

Order Information: Each order contains the following details:

----------------------------------------
Field			Description
----------------------------------------
orderId			Unique order identifier
customerName	Name of the customer
productName		Product ordered
quantity		Number of items
pricePerUnit	Cost per item
totalAmount		quantity × price
----------------------------------------

Input Format:
-------------
NUMBER_OF_ORDERS, N
Next N lines: orderId customerName productName quantity pricePerUnit


Sample Input:
-------------
3
1001 Alice Laptop 1 75000
1002 Bob Phone 2 20000
1003 Charlie Tablet 1 30000

Sample Output:
--------------
PRODUCED Order[ID=1001, Customer=Alice, Product=Laptop, Qty=1, Total=75000.0]
CONSUMED Order[ID=1001, Total=75000.0]
PRODUCED Order[ID=1002, Customer=Bob, Product=Phone, Qty=2, Total=40000.0]
CONSUMED Order[ID=1002, Total=40000.0]
PRODUCED Order[ID=1003, Customer=Charlie, Product=Tablet, Qty=1, Total=30000.0]
CONSUMED Order[ID=1003, Total=30000.0]