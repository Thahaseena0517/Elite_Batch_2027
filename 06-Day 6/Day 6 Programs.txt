Day 6 Programs

In a film festival, there is a lineup of movies, each with a rating. The festival 
organizer wants to find the maximum total rating of 'k' sequence of movies while 
following these rules:
    1. The sequence must be exactly k movies long.
    2. Each movie in the sequence must have a distinct rating.
    3. None of the movies in the sequence should have a restricted rating, as 
       these are reserved for special screenings.

Given an array movieRatings representing the sequence of movie ratings, an integer k 
representing the length of the sequence, and a set restrictedRatings (of size m) of 
special ratings, find the maximum total rating of any valid sequence. 
If no valid sequence exists, return -1.

Input Format:
-------------
Line-1: 3 space separated integers, n, k, m
Line-2: n space separated integers, movieRatings[].
Line-3: m space separated integers, restrictedRatings[].

Output Format:
-------------
An integer, the maximum total rating of any valid sequence


Sample Input-1:
---------------
7 3 2
1 5 4 2 9 9 9
2 9

Sample Output-1:
----------------
10

Explanation: 
------------
The sequences of movie ratings with length 3 are:
- [1, 5, 4] which meets the requirements and has a total rating of 10.
- [5, 4, 2] which does not meet the requirements because 2 is in the 
restricted set.
- [4, 2, 9] which does not meet the requirements because 2 and 9 are in 
the restricted set.
- [2, 9, 9] which does not meet the requirements because 2 and 9 are in 
the restricted set and 9 is repeated.
- [9, 9, 9] which does not meet the requirements because 9 is in 
the restricted set and repeated.

We return 10 because it is the maximum total rating of all the sequences 
that meet the conditions.


Sample Input-2:
---------------
3 3 1
4 4 4
4

Sample Output-2:
----------------
-1

Explanation: The sequences of movie ratings with length 3 are:
[4, 4, 4] which does not meet the requirements because 4 is repeated and in the restricted set.
We return -1 because no sequences meet the conditions.

Constraints:
------------
0 <= m <= n <=1000
k <= n
0 ≤ restrictedRatings.length ≤ 1000

import java.util.*;
class Sol{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        int m=sc.nextInt();
        int[] arr=new int[n];
        for(int l=0;l<n;l++){
            arr[l]=sc.nextInt();
        }
        // int[] res=new int[m];
        Set<Integer> set=new HashSet<>();
        for(int l=0;l<m;l++){
            set.add(sc.nextInt());
        }
        int i=0,j=0;
        int sum=0;
        int maxi=-1;
        Map<Integer,Integer> freq=new HashMap<>();
        while(j<n){
            freq.put(arr[j],freq.getOrDefault(arr[j],0)+1);
            if(!set.contains(arr[j]) && freq.get(arr[j])==1){
                sum+=arr[j];
            }
            else{
                freq.clear();
                sum=0;
                i=j+1;
            }
            if(j-i+1<k) j++;
            else if(j-i+1==k){
                maxi=Math.max(maxi,sum);
                sum-=arr[i];
                freq.put(arr[i],freq.get(arr[i])-1);
                if(freq.get(arr[i])==0){
                    freq.remove(arr[i]);
                }
                i++;
                j++;
            }
        }
        System.out.println(maxi);
    } 
}

D6 Program-2
Trivikram and Vamshi are friends. They need to write N screen-plays, numbered 
from 1 to N. Each screen-play requires specific number of papers to write.

Initially, Trivikram has T number of papers in his box and Vamshi has V number of 
papers in his box. They have started the screenplay writing in the following way:
    - Trivikram starts from screen-play number 1 to N and Vamshi starts from N to 1.
    - They begin writing the screen-plays at same time.
    - Each screen-play takes same amount of time, irrespective of its size.
    - Trivikram or Vamshi must write the screen-play, if they have enough number 
      of papers in their respective boxes. Otherwise, they first have to refill 
      their boxes (instantly) and then write the screen-play.
    - In case, Trivikram and Vamshi reach the same screen-play, the one with more
      number of papers currently in their box should write the screen-play. If 
      they have the same number of papers, then Trivikram should write the 
      screen-play.

You are given 1-indexed integer array screen-play[] of size N, where screen-play[i]
is the number of papers required for ith screen-play, and two integers T and V.
Your task is to return the number of times they have to refill to write all the 
screen-plays.

Constraint:
-----------
max(screen-play) < T,V < 10^9


Input Format:
-------------
Line-1: 3 space separated integers, indicates N, T and V.
Line-2: N space separated integers, screen-plays[].

Output Format:
--------------
Print an integer result.


Sample Input-1:
---------------
6 10 10
5 3 4 4 5 4

Sample Output-1:
----------------
2

Explanation: 
------------
- Initially, Trivikram and Vamshi have 10 papers each in their boxes.
- Trivikram writes Screen-play-1, Vamshi writes Screen-play-6.
- Trivikram and Vamshi now have 5 and 6 papers in their boxes respectively.
- Trivikram writes Screen-play-2, Vamshi writes Screen-play-5.
- Trivikram and Vamshi now have 2 and 1 papers in their boxes respectively.
- Trivikram and Vamshi do not have enough number of papers to write screen-play-3 
and screen-play-4 , so they refills their boxes and finished the screenplays.
So, the total number of times they have to refill is 0 + 0 + 1 + 1 + 0 + 0 = 2.


Sample Input-2:
---------------
3 9 7
4 5 2

Sample Output-2:
----------------
0

Explanation: 
------------
- Initially, Trivikram and Vamshi have 9 papers and 7 papers each in their boxes.
- Trivikram writes Screen-play-1, Vamshi writes Screen-play-3.
- Trivikram and Vamshi now have 5 papers each in their boxes respectively.
- Now, Trivikram writes Screen-play-2. Finished the screenplays.
So, the total number of times they have to refill is 0 + 0 + 0 = 0.
import java.util.*;
class Sol{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int t=sc.nextInt();
        int v=sc.nextInt();
        int t1=t;
        int v1=v;
        int[] arr=new int[n];
        for(int l=0;l<n;l++){
            arr[l]=sc.nextInt();
        }
        int i=0,j=n-1;
        int refill=0;
        while(i<j){
                if(arr[i]>t){
                    t=t1;
                    refill++;
                }
                t-=arr[i];
                i++;
              
                if(arr[j]>v){
                    v=v1;
                    refill++;
                }
                v-=arr[j];
                j--;
   
       
            
        }
        System.out.println(refill);
        
    }
}

You are the chief designer for a futuristic garden trail, where there are N 
consecutive decorative light posts along a path. Each post can be illuminated 
with one of three distinct colors: Crimson, Azure, or Emerald. The cost to 
illuminate each post with a particular color depends on the post's location 
and the energy circuit required.

However, to maintain aesthetic harmony and prevent power circuit overloads, 
no two adjacent posts can have the same light color.

The cost of illuminating each post with each color is provided in a 2D array 
costs, where costs[i][0] is the cost of lighting post i with Crimson, costs[i][1] 
with Azure, and costs[i][2] with Emerald.

Your goal is to find the minimum total cost to light up all posts in such a way 
that no two neighboring posts have the same color.

Input Format:
-------------
Line-1: An integer N, number of post.
Next N lines: 3 space separated integers, cost of illuminating the posts.

Output Format:
--------------
Print an integer, minimum total cost to light up all posts.


Sample Input:
---------------
3
17 2 17
16 4 5
14 3 19

Sample Output:
----------------
10

Explanation: 
------------
1st post is with Azure, 2nd post is with Emerald,
3rd post is with Crimson.
Minimum cost: 2 + 5 + 3 = 10.

import java.util.*;
class Sol{
    public static int rec(int[][] arr,int i, int prev){
        if(i==arr.length) return 0;
        int ans=Integer.MAX_VALUE;
        for(int j=0;j<3;j++){
            if(prev!=j){
                ans=Math.min(ans,arr[i][j]+rec(arr,i+1,j));
            }
        }
        return ans;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[][] arr=new int[n][3];
        for(int i=0;i<n;i++){
            for(int j=0;j<3;j++){
                arr[i][j]=sc.nextInt();
            }
        }
        System.out.print(rec(arr,0,-1));
    }
}