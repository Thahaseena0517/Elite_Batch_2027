Day 11 programs
The integer array arr[] is given and print the resultant value of the bitwise OR
of the sum of all the possible sub-arrays of the given array arr[].

Note: A sub-array is a sequence of array-elements that could be drawn from other
      sequence of array-elements by removing zero or more elements without changing 
      the order of the remaining elements.



Input Format
-------------
Line-1: Read the size of array P.
Line-2: Read the array elements(space separated values).

Output Format
--------------
Print the resultant value.


Sample input-1:
---------------
4
0 2 1 3
Sample output-1:
----------------
7

Explanation
The sums of sub-arrays are
0 1 2 3 4 5 6. 
and bitwise OR operation
0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7.



Sample input-2:
---------------
4
0 0 0 0
Sample output-2:
----------------
0

Explanation
Only one sum sub-arrays i.e. 0.

//32 n solution


Balbir Singh is working with Binary Trees.
The elements of the tree are given in level-order format.

Balbir is observing the tree from the right side, meaning he 
can only see the rightmost nodes (one node per level).

You are given the root of a binary tree. Your task is to determine 
the nodes visible from the right side and return them in top-to-bottom order.

Refernce Node:
--------------
class TreeNode {
    Integer val;
    TreeNode left, right;
    
    TreeNode(Integer val) {
        this.val = val;
        this.left = this.right = null;
    }
}


Input Format:
-------------
Space separated integers, elements of the tree.

Output Format:
--------------
A list of integers representing the node values visible from the right side


Sample Input-1:
---------------
1 2 3 5 -1 -1 5

Sample Output-1:
----------------
[1, 3, 5]



Sample Input-2:
---------------
3 2 4 3 2

Sample Output-2:
----------------
[3, 4, 2]


import java.util.*;
class Sol{
    static class Node{
        int data;
        Node left;
        Node right;
        Node(int data){
            this.data=data;
        }
    }
    static Node buildTree(int[] arr){
        if(arr.length==0 || arr[0]==0) return null;
        Node root=new Node(arr[0]);
         Queue<Node> q=new LinkedList<>();
         q.add(root);
         int i=1;
         while(!q.isEmpty() && i<arr.length){
             Node curr=q.poll();
             if(i<arr.length && arr[i]!=-1){
                 Node left=new Node(arr[i]);
                 curr.left=left;
                 q.add(left);
             }
             i++;
             if(i<arr.length && arr[i]!=-1){
                 Node right=new Node(arr[i]);
                 curr.right=right;
                 q.add(right);
             }
             i++;
         }
         return root;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String[] line=sc.nextLine().split(" ");
        int[] arr=new int[line.length];
        for(int i=0;i<arr.length;i++){
            arr[i]=Integer.parseInt(line[i]);
        }
        Node root=buildTree(arr);
        System.out.println(right(root));
    }
    
    static ArrayList<Integer> right(Node root){
         ArrayList<Integer> ans=new ArrayList<>();
         if(root==null) return ans;
         Queue<Node> q=new LinkedList<>();
         q.add(root);
        //  int level=0;
         while(!q.isEmpty()){
             int n=q.size();
            //  System.out.println("In level: "+level);
             for(int i=0;i<n;i++){
                 Node curr=q.poll();
                //  System.out.print(curr.data+" ");
                 if(i==n-1) ans.add(curr.data);
                 if(curr.left!=null ) q.add(curr.left);
                 if(curr.right!=null) q.add(curr.right);
             }
            //  level++;
         }
         return ans;
    }
}